<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crypto Dashboard — Free, No Backend</title>
<style>
  :root {
    --bg: #0f1115;
    --panel: #151924;
    --text: #e6e9ef;
    --muted: #8b94a7;
    --accent: #6ae3ff;
    --positive: #2ecc71;
    --negative: #ff6b6b;
    --warn: #ffb020;
    --border: #262c3a;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: linear-gradient(180deg, #0f1115 0%, #0b0d12 100%);
    color: var(--text);
  }
  header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 20px; border-bottom: 1px solid var(--border);
    position: sticky; top: 0; background: rgba(15,17,21,0.8); backdrop-filter: blur(8px); z-index: 10;
  }
  h1 { margin: 0; font-size: 18px; letter-spacing: 0.5px; }
  .btn {
    background: var(--panel); color: var(--text); border: 1px solid var(--border);
    padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600;
  }
  .btn:hover { border-color: var(--accent); color: #fff; }
  .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
  .grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 14px;
  }
  .card {
    background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 14px;
  }
  .card h3 { margin: 0 0 8px; font-size: 16px; }
  .row { display: flex; justify-content: space-between; align-items: center; margin: 6px 0; }
  .small { color: var(--muted); font-size: 12px; }
  .price { font-size: 18px; font-weight: 700; }
  .badge { padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid var(--border); background: #121622; }
  .badge.ok { color: var(--positive); border-color: rgba(46,204,113,0.3); }
  .badge.err { color: var(--negative); border-color: rgba(255,107,107,0.3); }
  .section-title { margin: 16px 0 8px; font-size: 14px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.1em; }
  .total {
    display: flex; gap: 16px; align-items: baseline; margin-bottom: 12px;
  }
  .total .value { font-size: 28px; font-weight: 800; }
  .muted { color: var(--muted); }
  .hr { height: 1px; background: var(--border); margin: 18px 0; }

  /* Modal */
  .modal-backdrop {
    position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 100;
  }
  .modal {
    background: var(--panel); border: 1px solid var(--border); border-radius: 12px; width: min(900px, 92vw);
    max-height: 86vh; overflow: hidden; display: flex; flex-direction: column;
  }
  .modal header { position: static; background: transparent; border-bottom: 1px solid var(--border); }
  .modal .content { padding: 14px; overflow: auto; }
  textarea {
    width: 100%; min-height: 320px; background: #0c0f17; color: var(--text); border: 1px solid var(--border);
    border-radius: 10px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px;
  }
  .modal .actions { display: flex; gap: 8px; padding: 12px; border-top: 1px solid var(--border); }
  .note { font-size: 12px; color: var(--muted); }
  code.inline { background: #0c0f17; border: 1px solid var(--border); padding: 0 6px; border-radius: 6px; }
</style>
</head>
<body>
  <header>
    <h1>Crypto Dashboard — Free, No Backend</h1>
    <div>
      <button class="btn" id="btn-refresh">Refresh</button>
      <button class="btn" id="btn-settings">Settings</button>
    </div>
  </header>

  <div class="container">
    <div class="section-title">Portfolio</div>
    <div class="card">
      <div class="total">
        <div class="value" id="portfolio-total">$0</div>
        <div class="muted" id="portfolio-meta">0 assets • 0 exchanges</div>
      </div>
      <div class="grid" id="portfolio-balances"></div>
    </div>

    <div class="hr"></div>

    <div class="section-title">Prices by exchange</div>
    <div class="grid" id="prices-grid"></div>

    <div class="hr"></div>

    <div class="note">
      Tip: Add a custom exchange in Settings using a URL template with {symbol}. Example
      <code class="inline">https://api.binance.com/api/v3/ticker/price?symbol={symbol}</code> and JSON path <code class="inline">price</code>.
    </div>
  </div>

  <!-- Settings modal -->
  <div class="modal-backdrop" id="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <header>
        <h1>Settings</h1>
        <div class="small">Your config is saved locally in your browser (no server).</div>
      </header>
      <div class="content">
        <p class="small">
          - Never paste API keys here. This is front-end only.<br/>
          - Balances are manual and used for valuation only.<br/>
          - Some exchanges block browsers (CORS). If a card shows error, use CoinGecko or another source.
        </p>
        <label class="small">Configuration (JSON)</label>
        <textarea id="config-editor"></textarea>
      </div>
      <div class="actions">
        <button class="btn" id="btn-reset">Reset to defaults</button>
        <div style="flex:1"></div>
        <button class="btn" id="btn-cancel">Cancel</button>
        <button class="btn" id="btn-save">Save</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   Config, storage, defaults
   ========================= */

const STORAGE_KEY = "crypto_dashboard_config_v2";

const DEFAULT_CONFIG = {
  fiat: "USD",
  refreshMs: 12000,
  // Coins to track. For each coin, map per-exchange symbols.
  coins: [
    {
      name: "Bitcoin",
      symbol: "BTC",
      gecko: "bitcoin",
      pairs: {
        binance: "BTCUSDT",
        coinbase: "BTC-USD"
      }
    },
    {
      name: "Ethereum",
      symbol: "ETH",
      gecko: "ethereum",
      pairs: {
        binance: "ETHUSDT",
        coinbase: "ETH-USD"
      }
    }
  ],
  // Exchanges: built-ins and custom. You can add new entries.
  exchanges: {
    coingecko: {
      enabled: true,
      type: "builtin",
      displayName: "CoinGecko",
      notes: "Aggregator spot price. No key."
    },
    binance: {
      enabled: true,
      type: "builtin",
      displayName: "Binance",
      notes: "Public ticker. No key."
    },
    coinbase: {
      enabled: true,
      type: "builtin",
      displayName: "Coinbase",
      notes: "Public spot price."
    },
    // Example custom (disabled by default)
    // "ok-custom": {
    //   enabled: false,
    //   type: "custom",
    //   displayName: "My Custom",
    //   urlTemplate: "https://api.example.com/ticker?symbol={symbol}",
    //   jsonPath: "price",
    //   pairs: { BTC: "BTCUSD", ETH: "ETHUSD" }
    // }
  },
  // Manual balances for valuation. Values in coin units.
  balances: {
    // Per asset (global)
    assets: {
      BTC: 0.0,
      ETH: 0.0
    },
    // Optional per-exchange split (informational)
    perExchange: {
      binance: { BTC: 0.0, ETH: 0.0 },
      coinbase: { BTC: 0.0, ETH: 0.0 }
    }
  }
};

function loadConfig() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return structuredClone(DEFAULT_CONFIG);
    const parsed = JSON.parse(raw);
    // Shallow merge defaults to preserve new fields across versions
    return mergeDeep(structuredClone(DEFAULT_CONFIG), parsed);
  } catch (e) {
    console.warn("Config parse error, using defaults", e);
    return structuredClone(DEFAULT_CONFIG);
  }
}

function saveConfig(cfg) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(cfg, null, 2));
}

function mergeDeep(target, source) {
  for (const k of Object.keys(source)) {
    if (source[k] && typeof source[k] === "object" && !Array.isArray(source[k])) {
      if (!target[k]) target[k] = {};
      mergeDeep(target[k], source[k]);
    } else {
      target[k] = source[k];
    }
  }
  return target;
}

/* =========================
   Fetch helpers
   ========================= */

const timeout = (ms) => new Promise((_, rej) => setTimeout(() => rej(new Error("Timeout")), ms));

async function getJSON(url, ms = 8000) {
  const res = await Promise.race([fetch(url), timeout(ms)]);
  if (!res.ok) throw new Error(res.status + " " + res.statusText);
  return res.json();
}

function byPath(obj, path) {
  if (!path) return undefined;
  return path.split(".").reduce((acc, k) => (acc ? acc[k] : undefined), obj);
}

/* =========================
   Price adapters (built-in)
   ========================= */

async function priceFromCoinGecko(geckoId, fiat = "USD") {
  const url = `https://api.coingecko.com/api/v3/simple/price?ids=${encodeURIComponent(geckoId)}&vs_currencies=${encodeURIComponent(fiat.toLowerCase())}`;
  const json = await getJSON(url);
  const v = json?.[geckoId]?.[fiat.toLowerCase()];
  if (v == null) throw new Error("No price");
  return Number(v);
}

async function priceFromBinance(symbol) {
  const url = `https://api.binance.com/api/v3/ticker/price?symbol=${encodeURIComponent(symbol)}`;
  const json = await getJSON(url);
  const v = json?.price;
  if (v == null) throw new Error("No price");
  return Number(v);
}

async function priceFromCoinbase(productOrPair) {
  // Accept "BTC-USD" (coinbase v2) or full product code.
  const url = `https://api.coinbase.com/v2/prices/${encodeURIComponent(productOrPair)}/spot`;
  const json = await getJSON(url);
  const v = json?.data?.amount;
  if (v == null) throw new Error("No price");
  return Number(v);
}

async function priceFromCustom(exchangeCfg, symbolForThisExchange) {
  const url = exchangeCfg.urlTemplate.replace("{symbol}", encodeURIComponent(symbolForThisExchange));
  const json = await getJSON(url);
  const v = byPath(json, exchangeCfg.jsonPath);
  if (v == null) throw new Error("No price at path: " + exchangeCfg.jsonPath);
  return Number(v);
}

/* =========================
   Rendering
   ========================= */

let CONFIG = loadConfig();
let REFRESH_HANDLE = null;

const els = {
  pricesGrid: document.getElementById("prices-grid"),
  portfolioTotal: document.getElementById("portfolio-total"),
  portfolioMeta: document.getElementById("portfolio-meta"),
  portfolioBalances: document.getElementById("portfolio-balances"),
  btnRefresh: document.getElementById("btn-refresh"),
  btnSettings: document.getElementById("btn-settings"),
  modalBackdrop: document.getElementById("modal-backdrop"),
  configEditor: document.getElementById("config-editor"),
  btnCancel: document.getElementById("btn-cancel"),
  btnSave: document.getElementById("btn-save"),
  btnReset: document.getElementById("btn-reset")
};

function fmtCurrency(n, fiat = "USD") {
  try {
    return new Intl.NumberFormat(undefined, { style: "currency", currency: fiat }).format(n);
  } catch {
    return "$" + (Number(n).toFixed(2));
  }
}
function fmtNum(n, d=6) {
  const x = Number(n);
  if (x >= 1000) return x.toLocaleString();
  if (x >= 1) return x.toFixed(2);
  if (x >= 0.01) return x.toFixed(4);
  return x.toFixed(d);
}

function renderPricesSkeleton() {
  els.pricesGrid.innerHTML = "";
  const enabledExchanges = Object.entries(CONFIG.exchanges).filter(([_, ex]) => ex.enabled);
  for (const coin of CONFIG.coins) {
    const card = document.createElement("div");
    card.className = "card";
    const lines = [];
    lines.push(`<h3>${coin.name} <span class="small">(${coin.symbol})</span></h3>`);
    for (const [exKey, exCfg] of enabledExchanges) {
      const label = exCfg.displayName || exKey;
      lines.push(`
        <div class="row">
          <div class="small">${label}</div>
          <div class="price" id="p_${coin.symbol}_${exKey}">…</div>
        </div>
      `);
    }
    lines.push(`<div class="row"><span class="small">Last update</span><span class="small" id="t_${coin.symbol}">—</span></div>`);
    card.innerHTML = lines.join("");
    els.pricesGrid.appendChild(card);
  }
}

async function updatePricesOnce() {
  const enabledExchanges = Object.entries(CONFIG.exchanges).filter(([_, ex]) => ex.enabled);
  const now = new Date().toLocaleTimeString();
  for (const coin of CONFIG.coins) {
    for (const [exKey, exCfg] of enabledExchanges) {
      const el = document.getElementById(`p_${coin.symbol}_${exKey}`);
      if (!el) continue;
      el.innerHTML = `<span class="badge">Fetching</span>`;
      try {
        let price = null;
        if (exCfg.type === "builtin") {
          if (exKey === "coingecko") {
            price = await priceFromCoinGecko(coin.gecko, CONFIG.fiat);
          } else if (exKey === "binance") {
            const sym = coin.pairs?.binance;
            if (!sym) throw new Error("Missing pair");
            price = await priceFromBinance(sym);
          } else if (exKey === "coinbase") {
            const sym = coin.pairs?.coinbase;
            if (!sym) throw new Error("Missing pair");
            price = await priceFromCoinbase(sym);
          } else {
            throw new Error("Unsupported builtin");
          }
        } else if (exCfg.type === "custom") {
          // symbol mapping order: exchange-specific pairs, then per-coin pairs, then symbol itself
          const sym = (exCfg.pairs && exCfg.pairs[coin.symbol]) ||
                      (coin.pairs && coin.pairs[exKey]) ||
                      coin.symbol;
          if (!exCfg.urlTemplate || !exCfg.jsonPath) throw new Error("Custom exchange requires urlTemplate and jsonPath");
          price = await priceFromCustom(exCfg, sym);
        } else {
          throw new Error("Unknown exchange type");
        }
        el.textContent = fmtNum(price);
        el.classList.remove("err");
        document.getElementById(`t_${coin.symbol}`).textContent = now;
      } catch (e) {
        el.innerHTML = `<span class="badge err">Error</span>`;
        console.warn(`Price error for ${coin.symbol} @ ${exKey}`, e);
      }
    }
  }
}

async function updatePortfolioValuation() {
  // Use CoinGecko as valuation source for each coin.
  let total = 0;
  let items = [];
  for (const coin of CONFIG.coins) {
    const bal = Number(CONFIG.balances?.assets?.[coin.symbol] || 0);
    let price = null;
    let value = 0;
    try {
      price = await priceFromCoinGecko(coin.gecko, CONFIG.fiat);
      value = bal * price;
      total += value;
      items.push({ coin, bal, price, value, ok: true });
    } catch (e) {
      items.push({ coin, bal, price: 0, value: 0, ok: false });
    }
  }

  els.portfolioTotal.textContent = fmtCurrency(total, CONFIG.fiat);
  const exCount = Object.values(CONFIG.exchanges).filter(x => x.enabled).length;
  els.portfolioMeta.textContent = `${items.length} assets • ${exCount} exchanges`;

  // Render per-asset cards
  els.portfolioBalances.innerHTML = "";
  for (const it of items) {
    const c = document.createElement("div");
    c.className = "card";
    c.innerHTML = `
      <h3>${it.coin.name} <span class="small">(${it.coin.symbol})</span></h3>
      <div class="row">
        <div class="small">Balance</div>
        <div>${fmtNum(it.bal)}</div>
      </div>
      <div class="row">
        <div class="small">Price (CG)</div>
        <div>${it.ok ? fmtNum(it.price) : `<span class="badge err">Error</span>`}</div>
      </div>
      <div class="row">
        <div class="small">Value</div>
        <div>${fmtCurrency(it.value, CONFIG.fiat)}</div>
      </div>
    `;
    els.portfolioBalances.appendChild(c);
  }
}

/* =========================
   Modal / settings
   ========================= */

function openSettings() {
  els.configEditor.value = JSON.stringify(CONFIG, null, 2);
  els.modalBackdrop.style.display = "flex";
  els.modalBackdrop.setAttribute("aria-hidden", "false");
}

function closeSettings() {
  els.modalBackdrop.style.display = "none";
  els.modalBackdrop.setAttribute("aria-hidden", "true");
}

els.btnSettings.addEventListener("click", openSettings);
els.btnCancel.addEventListener("click", closeSettings);
els.btnReset.addEventListener("click", () => {
  if (!confirm("Reset configuration to defaults?")) return;
  CONFIG = structuredClone(DEFAULT_CONFIG);
  saveConfig(CONFIG);
  boot();
  closeSettings();
});
els.btnSave.addEventListener("click", () => {
  try {
    const next = JSON.parse(els.configEditor.value);
    // Minimal validation
    if (!next || typeof next !== "object") throw new Error("Invalid JSON");
    if (!next.coins || !Array.isArray(next.coins)) throw new Error("Config.coins must be an array");
    if (!next.exchanges || typeof next.exchanges !== "object") throw new Error("Config.exchanges must be an object");
    CONFIG = mergeDeep(structuredClone(DEFAULT_CONFIG), next);
    saveConfig(CONFIG);
    boot();
    closeSettings();
  } catch (e) {
    alert("Invalid configuration: " + e.message);
  }
});

/* =========================
   Lifecycle
   ========================= */

els.btnRefresh.addEventListener("click", () => {
  updatePricesOnce();
  updatePortfolioValuation();
});

function stopAutoRefresh() {
  if (REFRESH_HANDLE) clearInterval(REFRESH_HANDLE);
  REFRESH_HANDLE = null;
}

function startAutoRefresh() {
  stopAutoRefresh();
  const ms = Math.max(5000, Number(CONFIG.refreshMs || 12000));
  REFRESH_HANDLE = setInterval(() => {
    updatePricesOnce();
    // Portfolio can update less often, but keep simple
    updatePortfolioValuation();
  }, ms);
}

async function boot() {
  renderPricesSkeleton();
  await Promise.allSettled([updatePricesOnce(), updatePortfolioValuation()]);
  startAutoRefresh();
}

boot();

/* =========================
   Quick tips for custom exchanges (in-code doc)
   =========================
   - Add a new exchange under config.exchanges:
     "myex": {
       "enabled": true,
       "type": "custom",
       "displayName": "MyEx",
       "urlTemplate": "https://api.myex.com/v1/ticker?symbol={symbol}",
       "jsonPath": "data.last",
       "pairs": { "BTC": "BTCUSD", "ETH": "ETHUSD" }
     }
   - Map symbols per coin (pairs) if the exchange uses different naming.
   - If a card shows "Error", the browser may be blocked by CORS. Try CoinGecko or Coinbase instead.
*/
</script>
</body>
</html>
